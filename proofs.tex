% vim: set spell spelllang=en tw=100 et sw=4 sts=4 foldmethod=marker foldmarker={{{,}}} :

\documentclass[aspectratio=169,compress,10pt]{beamer}

\usepackage{tikz}
\usepackage{xcolor}
\usepackage{complexity}
\usepackage{hyperref}
\usepackage{microtype}
\usepackage{amsmath}                   % \operatorname
\usepackage{amsfonts}                  % \mathcal
\usepackage{amssymb}                   % \nexists
\usepackage[vlined]{algorithm2e} % algorithms
\usepackage{centernot}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{pifont}
\usepackage{bussproofs}
\usepackage{marvosym}
\usepackage{multicol}

\usefonttheme{professionalfonts}

\usetikzlibrary{shapes, arrows, shadows, calc, positioning, fit}
\usetikzlibrary{decorations.pathreplacing, decorations.pathmorphing, shapes.misc}
\usetikzlibrary{tikzmark, backgrounds}
\usetikzlibrary{trees}
\usetikzlibrary{overlay-beamer-styles}

\definecolor{uofguniversityblue}{rgb}{0, 0.219608, 0.396078}

\definecolor{uofgheather}{rgb}{0.356863, 0.32549, 0.490196}
\definecolor{uofgaquamarine}{rgb}{0.603922, 0.72549, 0.678431}
\definecolor{uofgslate}{rgb}{0.309804, 0.34902, 0.380392}
\definecolor{uofgrose}{rgb}{0.823529, 0.470588, 0.709804}
\definecolor{uofgmocha}{rgb}{0.709804, 0.564706, 0.47451}
\definecolor{uofgsandstone}{rgb}{0.321569, 0.278431, 0.231373}
\definecolor{uofgforest}{rgb}{0, 0.2, 0.129412}
\definecolor{uofglawn}{rgb}{0.517647, 0.741176, 0}
\definecolor{uofgcobalt}{rgb}{0, 0.615686, 0.92549}
\definecolor{uofgturquoise}{rgb}{0, 0.709804, 0.819608}
\definecolor{uofgsunshine}{rgb}{1.0, 0.862745, 0.211765}
\definecolor{uofgpumpkin}{rgb}{1.0, 0.72549, 0.282353}
\definecolor{uofgthistle}{rgb}{0.584314, 0.070588, 0.447059}
\definecolor{uofgrust}{rgb}{0.603922, 0.227451, 0.023529}
\definecolor{uofgburgundy}{rgb}{0.490196, 0.133333, 0.223529}
\definecolor{uofgpillarbox}{rgb}{0.701961, 0.047059, 0}
\definecolor{uofglavendar}{rgb}{0.356863, 0.301961, 0.580392}

\tikzset{vertex/.style={draw, circle, inner sep=0pt, minimum size=0.5cm, font=\small\bfseries}}
\tikzset{notvertex/.style={vertex, color=white, text=black}}
\tikzset{plainvertex/.style={vertex}}
\tikzset{vertexc1/.style={vertex, fill=uofgburgundy, text=white}}
\tikzset{vertexc2/.style={vertex, fill=uofgsandstone, text=white}}
\tikzset{vertexc3/.style={vertex, fill=uofgforest, text=white}}
\tikzset{vertexc4/.style={vertex, fill=uofgheather, text=white}}
\tikzset{edge/.style={color=black!50!white}}
\tikzset{bedge/.style={ultra thick}}
\tikzset{edged/.style={color=screengrey, dashed}}
\tikzset{edgel3/.style={color=uofgrose, ultra thick}}

% {{{ theme things
\useoutertheme[footline=authortitle]{miniframes}
\useinnertheme{rectangles}

\setbeamerfont{block title}{size={}}
\setbeamerfont{title}{size=\large,series=\bfseries}
\setbeamerfont{section title}{size=\large,series=\mdseries}
\setbeamerfont{author}{size=\normalsize,series=\mdseries}
\setbeamercolor*{structure}{fg=uofguniversityblue}
\setbeamercolor*{palette primary}{use=structure,fg=black,bg=white}
\setbeamercolor*{palette secondary}{use=structure,fg=white,bg=uofgcobalt}
\setbeamercolor*{palette tertiary}{use=structure,fg=white,bg=uofguniversityblue}
\setbeamercolor*{palette quaternary}{fg=white,bg=black}
\setbeamercolor{block body}{bg=structure!10}
\setbeamercolor{block title}{bg=structure,fg=white}
\setbeamertemplate{blocks}[rounded]
\setbeamercolor*{titlelike}{parent=palette primary}

\beamertemplatenavigationsymbolsempty

\setbeamertemplate{title page}
{
    \begin{tikzpicture}[remember picture, overlay]
        \node at (current page.north west) {
            \begin{tikzpicture}[remember picture, overlay]
                \fill [fill=uofguniversityblue, anchor=north west] (0, 0) rectangle (\paperwidth, -2.6cm);
            \end{tikzpicture}
        };

        \node (logo) [anchor=north east, shift={(-0.8cm,-0.2cm)}] at (current page.north east) {
            \includegraphics[keepaspectratio=true,scale=0.5]{UoG_keyline.pdf}
        };

        \node (logo2) [anchor=north, below=0.2cm of logo.south] {
            \includegraphics[keepaspectratio=true,scale=0.1]{RAEngWhite.pdf}
        };

        \coordinate (logos) at ($(logo.south)!0.5!(logo2.north)$);

        \node [anchor=west, xshift=0.8cm] at (current page.west |- logos) {
            \begin{minipage}{0.65\paperwidth}\raggedright
                {\usebeamerfont{title}\usebeamercolor[white]{}\inserttitle}\\[0.1cm]
                {\usebeamerfont{author}\usebeamercolor[white]{}\insertauthor}
            \end{minipage}
        };
    \end{tikzpicture}
}

\setbeamertemplate{section page}
{
    \begin{centering}
        \begin{beamercolorbox}[sep=12pt,center]{part title}
            \usebeamerfont{section title}\insertsection\par
        \end{beamercolorbox}
    \end{centering}
}

\newcommand{\frameofframes}{/}
\newcommand{\setframeofframes}[1]{\renewcommand{\frameofframes}{#1}}

\makeatletter
\setbeamertemplate{footline}
{%
    \begin{beamercolorbox}[colsep=1.5pt]{upper separation line foot}
    \end{beamercolorbox}
    \begin{beamercolorbox}[ht=2.5ex,dp=1.125ex,%
        leftskip=.3cm,rightskip=.3cm plus1fil]{author in head/foot}%
        \leavevmode{\usebeamerfont{author in head/foot}\insertshortauthor}%
        \hfill%
        {\usebeamerfont{institute in head/foot}\usebeamercolor[fg]{institute in head/foot}\insertshortinstitute}%
    \end{beamercolorbox}%
    \begin{beamercolorbox}[ht=2.5ex,dp=1.125ex,%
        leftskip=.3cm,rightskip=.3cm plus1fil]{title in head/foot}%
        {\usebeamerfont{title in head/foot}\insertshorttitle}%
        \hfill%
        {\usebeamerfont{frame number}\usebeamercolor[fg]{frame number}\insertframenumber~\frameofframes~\inserttotalframenumber}
    \end{beamercolorbox}%
    \begin{beamercolorbox}[colsep=1.5pt]{lower separation line foot}
    \end{beamercolorbox}
}

\makeatletter
\setbeamertemplate{mini frame}
{%
  \begin{pgfpicture}{0pt}{0pt}{.04cm}{.04cm}
    \pgfpathcircle{\pgfpoint{0.04cm}{0.04cm}}{0.04cm}
    \pgfusepath{fill,stroke}
  \end{pgfpicture}%
}
\setbeamertemplate{mini frame in current subsection}
{%
  \begin{pgfpicture}{0pt}{0pt}{.04cm}{.04cm}
    \pgfpathcircle{\pgfpoint{0.04cm}{0.04cm}}{0.04cm}
    \pgfsetfillcolor{section in head/foot.bg}
    \pgfusepath{fill,stroke}
  \end{pgfpicture}%
}

\setbeamersize{mini frame size=0.10cm, mini frame offset=0.06cm}
\makeatother

% }}}

\newcommand<>{\alertred}[1]{{\color#2{uofgthistle}#1}}
\newcommand<>{\alertblue}[1]{{\color#2{uofgcobalt}#1}}
\newcommand<>{\alertgreen}[1]{{\color#2{uofglawn}#1}}

\providecommand{\cdclwidthfirstcol}{0.33\textwidth}
\providecommand{\cdclwidthsecondcol}{0.65\textwidth}
\providecommand{\cdclformulaleftadjust}{\hspace{-1.5mm}}
\renewcommand{\cdclformulaleftadjust}{}
\providecommand{\landwsp}{\,\land\,}
\providecommand{\alertedor}{\:\lor\:}
\newcommand{\olnot}[1]{\overline{#1}}
\newcommand{\Redlightning}{\alertred{\Lightning}}
\newcommand{\emptycl}{\bot}

\tikzstyle{state} = [inner sep=1pt]
\tikzstyle{accept} = [solid, thick]
\tikzstyle{reject} = [dotted, thick]

\author{Ciaran McCreesh}
\title{Proof Logging}

\begin{document}

{
    \usebackgroundtemplate{
        \tikz[overlay, remember picture]
        \node[at=(current page.south), anchor=south, inner sep=0pt, yshift=-1cm]{\includegraphics[keepaspectratio=true, width=\paperwidth]{background4.jpg}};
    }
    \begin{frame}[plain,noframenumbering]
        \titlepage
    \end{frame}
}

\begin{frame}{Demotivation}
    My first experience of research: a summer internship reimplementing a clique algorithm from the literature.

    \bigskip

    My code produced the ``wrong'' answer on a few instances.

    \bigskip\pause

    I spent a month trying to find and fix it.

    \bigskip\pause

    The published answers were wrong.
\end{frame}

\begin{frame}{How Do We Know Our Solvers Are Correct?}
    I've wanted to write a CP solver for years.

    \bigskip

    How will I know it's right? What if I ruin some poor student's life by publishing wrong answers?

    \bigskip\pause

    What if someone uses my solver for kidney exchange or workplace allocation or deciding adoptive parents?
\end{frame}

\begin{frame}{The Slide That ``They'' Don't Want Me to Show You}
    The 2021 MiniZinc challenge: for 1.28\% of instances, wrong solutions were claimed.
    \\
    \begin{itemize}
        \item False claims of unsatisfiability.
        \item False claims of optimality.
        \item Infeasible solutions produced.
        \item Not limited to a single solver, problem, or constraint.
        \item Not even consistent---same solver on same hardware and same instance can give
            different results on different runs.
    \end{itemize}
    \bigskip
    I don't want my solver to produce wrong answers!

    \bigskip\pause

    Or at least, when it's wrong, I want a guaranteed way of detecting it.
\end{frame}

\begin{frame}{Testing?}
    \only<1>{\begin{itemize}
        \item Traditional software engineering testing techniques only catch shallow bugs.
        \item Basically useless for complicated algorithms\ldots
        \item We do have special ways of testing constraint solvers.
    \end{itemize}}
    \only<2>{
        \centering\includegraphics[keepaspectratio=true,scale=0.35]{testing1.png}
    }
    \only<3>{
        \centering\includegraphics[keepaspectratio=true,scale=0.35]{testing2.png}
    }
    \only<4>{
        ``It is now two decades since it was pointed out that program testing
        may convincingly demonstrate the presence of bugs, but can never
        demonstrate their absence. After quoting this well-publicized remark
        devoutly, the software engineer returns to the order of the day and
        continues to refine his testing strategies, just like the alchemist of
        yore, who continued to refine his chrysocosmic purifications.''

        \flushright -- Edsger W. Dijkstra\\``On the cruelty of really teaching computing science''}
\end{frame}

\begin{frame}{Formal Methods / Correct By Construction Software}
    \begin{itemize}
        \item Can't even do a bad implementation of all-different yet\ldots
        \item The fast unit propagation for SAT is also beyond the reach of
            formal methods.
    \end{itemize}
\end{frame}

\begin{frame}{Another Option?}
    \begin{itemize}
        \item Idea: maybe checking that an answer is right is simpler than
            checking an algorithm?\pause
        \item This is my research area. It's brand new and I don't know how to explain or teach it
            yet.\pause
        \item Or\ldots Maybe I'm trying to justify spending a million pounds of taxpayer and
            charity money over five years.
    \end{itemize}
\end{frame}

\begin{frame}[t]{Proof Logging in SAT}
    \only<1>{\begin{itemize}
        \item Certifying algorithms:
            \begin{itemize}
                \item Must produce a proof alongside an output.
                \item Verify outputs, not solvers.
            \end{itemize}
        \item A variety of formats for SAT: \ldots, DRAT, FRAT, \ldots.
            \begin{itemize}
                \item Unsat is the hard part.
            \end{itemize}
        \item Huge success for SAT solving.
    \end{itemize}}\only<2-4>{
    \begin{center}
        \includegraphics<2>[keepaspectratio=true,scale=0.30]{shortest-math-paper.jpg}
        \includegraphics<3-4>[keepaspectratio=true,scale=0.65]{nature.png}
    \end{center}

        \smallskip

        \only<4>{Mathematicians care much more about correctness than software engineers. It's a
        good thing pure mathematics has lots of real-world applications, whereas software engineering
        has no impact upon people's lives.}
}
\end{frame}

\begin{frame}{SAT Proof Logging Workflow}
    \vspace*{-1.0em}
    \begin{center}
        \begin{tikzpicture}
            \node (solver) [%
            inner xsep=5em,
            inner ysep=2.5em,
            draw, rounded corners=3pt] { Solver };

            \node (checker) [%
            right=2cm of solver.north east,
            anchor=north west,
            inner xsep=0.25em,
            draw, rounded corners=3pt,
            minimum height=12em,
            visible on=<3->] { Checker };

            \node (print) [anchor=south, above=0cm of solver.south, visible on=<2->] { added print statements };
            \draw [dotted, visible on=<2->] (solver.west|-print.north) -- (solver.east|-print.north);

            \draw [->, thick] (solver.east) -- (solver.east -| checker.west)
                coordinate [midway] (solutionmid) node [above, midway]
                {
                  Result
                };

            \draw [->, thick, rounded corners=3pt, visible on=<2->] (solver.south) -- (solver.south |- checker.west)
                -- (checker.west) coordinate [midway] (proofmid);

            \coordinate (prooflabel) at (proofmid-|solutionmid);
            \node [above=0cm of prooflabel, visible on=<2->] { Proof };

            \coordinate [right=1.5cm of checker.east] (verified);
            \draw [->, thick, visible on=<4->] (checker.east) -- (verified) node [above, midway] { \textcolor{uofglawn}{\ding{51}} or \textcolor{uofgpillarbox}{\ding{55}} };

            \coordinate [left=1.5cm of solver.west] (input);
            \draw [->, thick] (input) -- (solver.west) coordinate [midway] (inputmid) node [above, midway] { Input };

            \coordinate (checkerbotleft) at ($(checker.west)+($(checker.west)-(solver.east-|checker.west)$)$);

            \draw [->, thick, rounded corners=3pt, visible on=<3->] ($(inputmid)+(-0.2,0)$) -- (inputmid) -- (inputmid |- checkerbotleft) -- (checkerbotleft);
        \end{tikzpicture}
      \end{center}
    \vspace*{-0.7em}
  \begin{enumerate}
  \item<1->
    Run solver on problem input.
  \item<2->
    Solver also prints out a proof as part of its output.
  \item<3->
    Feed input + solution + proof to proof checker.
  \item<4->
    Verify that proof checker says solution is correct.
  \end{enumerate}
\end{frame}

\begin{frame}{What is a Proof?}
    \begin{itemize}
        \item Start with some known facts, and some rules.
        \item Use the rules to create new facts.
        \item End up with the thing we're trying to prove.
            \begin{itemize}
                \item Rules have to be \emph{sound}.
                \item Today we're going to be talking about \emph{equisatisfiability}.
                \item Proof system has to be \emph{complete}.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Resolution Proofs for CNF}
\only<1>{
    \begin{minipage}[c]{0.25\framewidth}
        \textcolor{uofgcobalt}{\textbf{Model axioms}}
    \end{minipage}\hfill\begin{minipage}[c]{0.70\framewidth}
        \centering From the input
    \end{minipage}\bigskip

    \begin{minipage}[c]{0.25\framewidth}
        \textcolor{uofgcobalt}{\textbf{Resolution}}
    \end{minipage}\hfill\begin{minipage}[c]{0.70\framewidth}\begin{prooftree}
        \AxiomC{$\textcolor{uofglawn}{x_1} \vee \textcolor{uofglawn}{x_2} \vee \ldots \vee
        \textcolor{uofglawn}{x_i} \vee \textcolor{uofgpillarbox}{c}$}
        \AxiomC{$\textcolor{uofgpillarbox}{\overline{c}} \vee \textcolor{uofgcobalt}{y_1} \vee
        \textcolor{uofgcobalt}{y_2} \vee \ldots \textcolor{uofgcobalt}{y_j}$}
        \BinaryInfC{$\textcolor{uofglawn}{x_1} \vee \textcolor{uofglawn}{x_2} \vee \ldots \vee
        \textcolor{uofglawn}{x_i} \vee \textcolor{uofgcobalt}{y_1} \vee
        \textcolor{uofgcobalt}{y_2} \vee \ldots \vee \textcolor{uofgcobalt}{y_j}$}
    \end{prooftree}\end{minipage}

    \bigskip

    \begin{itemize}
        \item To prove unsatisfiability: resolve until you reach the empty clause.
    \end{itemize}
}
    \only<2->{
        \begin{minipage}[c]{0.30\framewidth}
            Input:
            \begin{align}
                & x \vee y \vee z \\
                & \overline{x} \vee \overline{y} \vee \overline{z} \\
                & \overline{x} \vee y \\
                & \overline{x} \vee z \\
                & x \vee \overline{y} \\
                & x \vee \overline{z} \\~\nonumber
            \end{align}
        \end{minipage}\hfill\begin{minipage}[c]{0.60\framewidth}
            Proof:
            \begin{align}
                & 1, 5 \operatorname{on} y && x \vee z \\
                & 6, 7 \operatorname{on} z && x \\
                & 3, 8 \operatorname{on} x && y \\
                & 4, 8 \operatorname{on} x && z \\
                & 2, 8 \operatorname{on} x && \overline{y} \vee \overline{z} \\
                & 9, 11 \operatorname{on} y && \overline{z} \\
                & 10, 12 \operatorname{on} z && \emptyset
            \end{align}

        \end{minipage}
    }
\end{frame}

\begin{frame}{Reverse Unit Propagation (RUP) Proofs}
    \begin{itemize}
        \item Unit propagation:
            \begin{itemize}
                \item Look for a clause containing just one literal $\ell$.
                \item Delete $\overline{\ell}$ from every other clause.
                \item Repeat until you can't do anything.
            \end{itemize}
        \item Reverse unit propagation:
            \begin{itemize}
                \item Add the negation of a constraint $C$, and unit propagate.
                \item If contradiction is reached, derive $C$.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[t]{Proofs for Davis-Putman-Logemann-Loveland (DPLL) SAT Solving}

  Very simple backtracking SAT solver: assign variables and propagate;
  backtrack when clause violated.

    \medskip

  When backtracking, write out negation of each guess as a RUP proof step.

  \begin{equation*}%
    \cdclformulaleftadjust
    (
    \alertgreen<5-5>{p}
    \lor
    \alertred<4-5>{\overline{u}}
    )
    \landwsp
    (
    q
    \lor
    r
    )
    \landwsp
    (
    \overline{r}
    \lor
    w
    )
    \landwsp
    (
    \alertgreen<4-5>{u}
    \lor
    \only<1-8>{\alertred<2-8>{x}}
    \only<9->{\alertgreen<9-10>{x}}
    \lor
    \only<1-5>{\alertred<3-5>{y}}
    \only<6->{\alertgreen<6-7>{y}}
    )
    \landwsp
    (
    \only<1-8>{\alertred<2-8>{x}}
    \only<9->{\alertgreen<9-10>{x}}
    \lor
    \only<1-5>{\alertgreen<3-5>{\overline{y}}}
    \only<6->{\alertred<6-7>{\overline{y}}}
    \lor
    \alertgreen<7,10>{z}
    )
    \landwsp
    (
    \only<1-8>{\alertgreen<2-8>{\overline{x}}}
    \only<9->{\alertred<9-10>{\overline{x}}}
    \lor
    \alertgreen<7,10>{z}
    )
    \landwsp
    (
    \only<1-5>{\alertgreen<3-5>{\overline{y}}}
    \only<6->{\alertred<6-7>{\overline{y}}}
    \alertred<7>{\alertedor}
    \alertred<7,10>{\overline{z}}
    )
    \landwsp
    (
    \only<1-8>{\alertgreen<2-8>{\overline{x}}}
    \only<9->{\alertred<9-10>{\overline{x}}}
    \alertred<10>{\alertedor}
    \alertred<7,10>{\overline{z}}
    )
    \landwsp
    (
    \alertred<5-5>{\overline{p}}
    \alertred<5-5>{\alertedor}
    \alertred<4-5>{\overline{u}}
    )
  \end{equation*}

  \medskip

  \begin{columns}[T]%
    \begin{column}{0.4\textwidth}

      \smallskip

      \begin{enumerate}
      \item <5-> $x \lor y$

        \smallskip

      \item <7-> $x \lor \olnot{y}$

        \smallskip

      \item <8-> $x$

        \smallskip

      \item <10-> $\olnot{x}$

        \smallskip

      \item <11-> $\emptycl$
      \end{enumerate}
    \end{column}
    \begin{column}{0.5\textwidth}
      \begin{tikzpicture}[sibling distance=4em, level distance=3.5em, align=center]
        \node [draw, circle, inner sep=2pt, visible on=<2->] {$x$}
        child { node [draw, circle, inner sep=2pt, visible on=<3->] {$y$}
          child { node [visible on=<5->] {\Redlightning} edge from parent [reject, visible on=<3->] node [left, visible on=<3->] {
$0$  %  $\overline{y}$
} }
          child { node [visible on=<7->] {\Redlightning} edge from parent [accept, visible on=<6->] node [right, visible on=<6->] {
$1$ % $y$
} }
          edge from parent [reject, visible on=<2->] node [left, visible on=<2->] {
$0$ % $\overline{x}$
}
        }
        child { node [visible on=<10->] {\Redlightning}
          edge from parent [accept, visible on=<9->] node [right, visible on=<9->] {
$1$  % $x$
 }
        }
        ;
      \end{tikzpicture}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Some Interesting Facts}
    \begin{itemize}
        \item Every RUP proof can be rewritten to a resolution proof in polynomial time and space.
        \item SAT solvers use conflict-driven clause learning learning, not backtracking. Each
            learned clause is still a RUP clause.
        \item The shortest resolution proofs for pigeonhole problems are exponentially long.
            \begin{itemize}
                \item <2-> So SAT solvers can't count\ldots
                \item <2-> And we need something better just to do all-different.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Opinionated Requirements For Proof Logging for CP}
    \begin{enumerate}
        \item Efficiently work with what solvers actually do, not idealised algorithms. \pause
        \item No need for a new proof format for every new propagator or solver.
            \begin{itemize}
                \item Constraint programming has 423 different global constraints, many of which
                    have several different propagators.
                \item Some propagators are buggy, and at least one has faulty theory behind it\ldots
            \end{itemize} \pause
        \item Proof format must still be simple and well-founded.
            \begin{itemize}
                \item Need to be able to trust the verifier.
                \item Interactions between features can be subtle: even deletions aren't that easy
                    to get right.
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Unexpected and Remarkable Claim}
    \begin{itemize}
        \item We can do everything we want with a proof format which is only slightly more
            sophisticated than resolution.
        \item <2-> Using proof logs during development leads to faster development than not doing proof logging.
    \end{itemize}
\end{frame}

\begin{frame}{VeriPB}
    \begin{center}
        \raisebox{-0.3em}{\url{https://gitlab.com/MIAOresearch/VeriPB}}
        \bigskip
    \end{center}
    \begin{itemize}
        \item MIT licence, written in Python with parsing in C++.
        \item Useful features like tracing and proof debugging.
    \end{itemize}
\end{frame}

\begin{frame}{Pseudo-Boolean Problems}
    \begin{minipage}[t]{0.25\framewidth}
        \textcolor{uofgcobalt}{\textbf{Variables}}
    \end{minipage}\hfill\begin{minipage}[c]{0.70\framewidth}
        $x_i \in \{ 0, 1 \}$
    \end{minipage}\bigskip

    \begin{minipage}[t]{0.25\framewidth}
        \textcolor{uofgcobalt}{\textbf{Literals}}
    \end{minipage}\hfill\begin{minipage}[c]{0.70\framewidth}
        $\{ x_i, \overline{x}_i \}$

        \medskip

        $\overline{x}_i$ defined to be $1 - x_i$, means ``not $x$''
    \end{minipage}\bigskip

    \begin{minipage}[t]{0.25\framewidth}
        \textcolor{uofgcobalt}{\textbf{Constraints}}
    \end{minipage}\hfill\begin{minipage}[c]{0.70\framewidth}
        $\sum_i a_i x_i \bowtie A$ for $a_i, A \in \mathbb{Z}$ and $\bowtie \,\in \{ \le, \ge \}$

        \medskip
        Can rewrite into normalised form with $a_i, A \in \mathbb{N}$ and $\bowtie\,=\,\ge$
    \end{minipage}
\end{frame}

\begin{frame}{Implications as Pseudo-Boolean Constraints}
    Can express implications
    \begin{equation*} y \Rightarrow 3x_1 + 2x_2 + x_3 + x_4 \ge 3 \end{equation*}
    as
    \begin{equation*}
    3\overline{y} + 3x_1 + 2x_2 + x_3 + x_4 \ge 3
    \end{equation*}

    \bigskip

    We can also do $\land_i y_i \Rightarrow C$ and $y \Leftarrow C$.
\end{frame}

\begin{frame}{Cutting Planes Proofs 1: Linear Inequalities}
    \begin{minipage}[c]{0.35\framewidth}
        \textcolor{uofgcobalt}{\textbf{Model axioms}}
    \end{minipage}\hfill\begin{minipage}[c]{0.60\framewidth}
        \centering From the input
    \end{minipage}\bigskip

    \begin{minipage}[c]{0.35\framewidth}
        \textcolor{uofgcobalt}{\textbf{Addition}}
    \end{minipage}\hfill\begin{minipage}[c]{0.60\framewidth}\begin{prooftree}
        \AxiomC{$\sum_i a_i \ell_i \ge A$}
        \AxiomC{$\sum_i b_i \ell_i \ge B$}
        \BinaryInfC{$\sum_i (a_i + b_i) \ell_i \ge A + B$}
    \end{prooftree}\end{minipage}\bigskip

    \begin{minipage}[c]{0.35\framewidth}
        \textcolor{uofgcobalt}{\textbf{Multiplication}}\\
        for any $c \in \mathbb{N^+}$
    \end{minipage}\hfill\begin{minipage}[c]{0.60\framewidth}\begin{prooftree}
        \AxiomC{$\sum_i a_i \ell_i \ge A$}
        \UnaryInfC{$\sum_i { c a_i \ell_i } \ge c A$}
    \end{prooftree}\end{minipage}
\end{frame}

\begin{frame}{Cutting Planes Proofs 2: 0-1 Variables}
    \begin{minipage}[c]{0.35\framewidth}
        \textcolor{uofgcobalt}{\textbf{Literal axioms}}
    \end{minipage}\hfill\begin{minipage}[c]{0.60\framewidth}\begin{prooftree}
        \AxiomC{~}
        \UnaryInfC{$\ell_i \ge 0$}
    \end{prooftree}\end{minipage}\bigskip

    \begin{minipage}[c]{0.35\framewidth}
        \textcolor{uofgcobalt}{\textbf{Division}}\\
        for any $c \in \mathbb{N^+}$ \\
        assumes normalised form
    \end{minipage}\hfill\begin{minipage}[c]{0.60\framewidth}\begin{prooftree}
        \AxiomC{$\sum_i a_i \ell_i \ge A$}
        \UnaryInfC{$\sum_i {\left\lceil \frac{a_i}{c} \right\rceil} \ell_i \ge \left\lceil \frac{A}{c} \right\rceil$}
    \end{prooftree}\end{minipage}\bigskip

    \begin{minipage}[c]{0.35\framewidth}
        \textcolor{uofgcobalt}{\textbf{Saturation}}\\
        assumes normalised form
    \end{minipage}\hfill\begin{minipage}[c]{0.60\framewidth}\begin{prooftree}
        \AxiomC{$\sum_i a_i \ell_i \ge A$}
        \UnaryInfC{$\sum_i \operatorname{min}\left(a_i, A\right) \ell_i \ge A$}
    \end{prooftree}\end{minipage}
\end{frame}

\begin{frame}{CNF, Resolution, and Implications}
    Pseudo-Boolean constraints are a superset of CNF clauses:
    \begin{equation*}
        a \lor \overline{b} \lor c \qquad \Leftrightarrow \qquad a + \overline{b} + c \ge 1
    \end{equation*}

    Remember the resolution rule:\bigskip

    \begin{minipage}[c]{0.35\framewidth}
        \textcolor{uofgcobalt}{\textbf{Resolution}}
    \end{minipage}\hfill\begin{minipage}[c]{0.60\framewidth}\begin{prooftree}
        \AxiomC{$a_1 \lor a_2 \lor \cdots \lor c$}
        \AxiomC{$\overline{c} \lor b_1 \lor b_2 \lor \cdots$}
        \BinaryInfC{$a_1 \lor a_2 \lor \cdots b_1 \lor b_2 \lor \cdots$}
    \end{prooftree}\end{minipage}\bigskip

    We can simulate this in cutting planes using addition then saturation.

    \pause
    \bigskip

    Another way of viewing this is:\bigskip

    \begin{minipage}[c]{0.35\framewidth}
        \textcolor{uofgcobalt}{\textbf{Resolution}}
    \end{minipage}\hfill\begin{minipage}[c]{0.60\framewidth}\begin{prooftree}
        \AxiomC{$(\overline{a}_1 \land \overline{a}_2 \land \cdots) \Rightarrow c$}
        \AxiomC{$c \Rightarrow (b_1 \lor b_2 \lor \cdots)$}
        \BinaryInfC{$(\overline{a}_1 \land \overline{a}_2 \land \cdots) \Rightarrow (b_1 \lor b_2 \lor \cdots)$}
    \end{prooftree}\end{minipage}
\end{frame}

\begin{frame}{Extended Cutting Planes Proofs}
    We'll also need a way of introducing a new variable that are true if and only if a certain
    constraint holds (\emph{reification}).

    \bigskip

    \begin{minipage}[c]{0.35\framewidth}
        \textcolor{uofgcobalt}{\textbf{Extension}}\\
        $y$ a fresh variable \\
        $C$ any constraint
    \end{minipage}\hfill\begin{minipage}[c]{0.60\framewidth}\begin{prooftree}
        \AxiomC{~}
        \UnaryInfC{$y \Rightarrow C$ \qquad $y \Leftarrow C$}
    \end{prooftree}\end{minipage}

    \bigskip

    In reality: we have a more general extension rule, but we don't need it today.
\end{frame}

\begin{frame}{Reverse Unit Propagation (RUP) Proofs Revisited}
    \begin{itemize}
        \item ``Unit propagation'' now means integer bounds consistency.
        \item A pseudo-Boolean constraint $C$ follows by ``reverse unit propagation'' (RUP) if\ldots
            \begin{itemize}
                \item Negating $C$, and
                \item Achieving bounds consistency on everything we know so far,
                \item Leads to a contradiction.
            \end{itemize}
        \item A VeriPB proof is a sequence of RUP constraints.
            \begin{itemize}
                \item Each constraint follows ``obviously'' from what we know so far.
                \item Final constraint is $0 \ge 1$, showing unsatisfiability.
                \item Can interleave cutting planes when we need to.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Another RUP Proof}
    \begin{minipage}[c]{0.45\framewidth}
        \begin{align*}
            2 x_1 + 2 x_2 + 3 x_3 + x_4 + 3 x_5 + 2 x_6 &\le 5 \\
            3 x_1 + 3 x_2 + 4 x_3 + x_4 + 3 x_5 + x_6   &\ge 8
        \end{align*}
        \pause
        \begin{center}
            \tikzstyle{level 1}=[level distance=1.20cm, sibling distance=2.00cm]
            \tikzstyle{level 2}=[level distance=1.20cm, sibling distance=1.00cm]
            \tikzstyle{level 3}=[level distance=1.20cm, sibling distance=0.5cm]
        \begin{tikzpicture}
            \node [state] { $x_1$ }
            child {
                node [state] { $x_2$ }
                child {
                    node {\Redlightning}
                    edge from parent [reject]
                }
                child {
                    node [state] { $x_3$ }
                    child {
                        node {\Redlightning}
                        edge from parent [reject]
                    }
                    child {
                        node {\Redlightning}
                        edge from parent [accept]
                    }
                    edge from parent [accept]
                }
                edge from parent [reject]
            }
            child {
                node [state] { $x_2$ }
                child {
                    node [state] { $x_3$ }
                    child {
                        node {\Redlightning}
                        edge from parent [reject]
                    }
                    child {
                        node {\Redlightning}
                        edge from parent [accept]
                    }
                    edge from parent [reject]
                }
                child {
                    node {\Redlightning}
                    edge from parent [accept]
                }
                edge from parent [accept]
            }
            ;
        \end{tikzpicture}
        \end{center}
    \end{minipage}\hfill
    \begin{minipage}[c]{0.45\framewidth}
        \begin{align*}
            \uncover<3->{\operatorname{rup}~ & x_1 + x_2 \ge 1} \\
            \uncover<4->{\operatorname{rup}~ & x_1 + \overline{x}_2 + x_3 \ge 1} \\
            \uncover<5->{\operatorname{rup}~ & x_1 + \overline{x}_2 + \overline{x}_3 \ge 1} \\
            \uncover<6->{\operatorname{rup}~ & x_1 + \overline{x}_2 \ge 1} \\
            \uncover<7->{\operatorname{rup}~ & x_1 \ge 1} \\
            \uncover<8->{\operatorname{rup}~ & \overline{x}_1 + x_2 + x_3 \ge 1} \\
            \uncover<8->{\operatorname{rup}~ & \overline{x}_1 + x_2 + \overline{x}_3 \ge 1} \\
            \uncover<8->{\operatorname{rup}~ & \overline{x}_1 + x_2 \ge 1} \\
            \uncover<8->{\operatorname{rup}~ & \overline{x}_1 \ge 1} \\
            \uncover<9->{\operatorname{rup}~ & 0 \ge 1}
        \end{align*}
    \end{minipage}
\end{frame}

\begin{frame}{A Slightly Different Workflow}
    \begin{center}
        \begin{tikzpicture}
            \node (solver) [inner xsep=5.5em, inner ysep=2.5em, draw, rounded corners=3pt] { Solver };

            \node (proofprinter) [
                inner ysep=.2em,
                rounded corners=3pt, anchor=south, xshift=1em, visible on=<4->] at (solver.south) { added print statements };

            \node (oldchecker) [right=2cm of solver.north east, anchor=north west,
            inner xsep=0.5em, draw, rounded corners=3pt, minimum height=12em,
            text width=4em, align=center, visible on=<1>] { \phantom{General}  Checker \phantom{Purpose} };

            \node (checker) [right=2cm of solver.north east, anchor=north west,
            inner xsep=0.5em, draw, rounded corners=3pt, minimum height=12em,
            text width=4em, align=center, visible on=<2->] { General Purpose Checker };

            \draw [->, thick] (solver.east) -- (solver.east -| checker.west)
                coordinate [midway] (solutionmid) node [above, midway] { Result };

            \draw [->, thick, rounded corners=3pt] (solver.south) -- (solver.south |- checker.west)
                -- (checker.west) coordinate [midway] (proofmid);

            \coordinate (prooflabel) at (proofmid-|solutionmid);
            \node [above=0cm of prooflabel] { Proof };

            \coordinate [right=1.5cm of checker.east] (verified);
            \draw [->, thick] (checker.east) -- (verified) node [above, midway] { \textcolor{uofglawn}{\ding{51}} or \textcolor{uofgpillarbox}{\ding{55}} };

            \coordinate [left=1.5cm of solver.west] (input);
            \draw [->, thick] (input) -- (solver.west) coordinate [midway] (inputmid) node [above, midway] { Input };

            \coordinate (checkerbotleft) at ($(checker.west)+($(checker.west)-(solver.east-|checker.west)$)$);

            \coordinate (solverstart) at ($(solver.south)!0.75!(solver.south west)$);
            \coordinate (solverstart2) at ($(solver.south)!0.65!(solver.south west)$);
            \draw [dotted, visible on=<3->] (solverstart2) -- (solverstart2 |- solver.north);
            \draw [->, thick, rounded corners=3pt, visible on=<3->] (solverstart) -- (solverstart |- checkerbotleft) -- (checkerbotleft);

            \draw [->, thick, rounded corners=3pt, visible on=<1-2>] ($(inputmid)+(-0.2,0)$) --
            (inputmid) -- (inputmid |- checkerbotleft) -- (checkerbotleft) coordinate [midway] (altinputmid);

            \draw [dotted, visible on=<4->] (solverstart2|-proofprinter.north) -- (solver.east|-proofprinter.north);

            \coordinate (prooflabel) at (altinputmid-|solutionmid);
            \node [above=0cm of prooflabel, xshift=-1.8cm, visible on=<3->] { Very Simple Encoding of Input };
        \end{tikzpicture}
      \end{center}

    \uncover<5->{
    \begin{itemize}
        \item Keep the compilation simple!
        \item For now: testing.
        \item Possible future direction: formally verified compilation.
    \end{itemize}}
\end{frame}

\begin{frame}[t]{Compiling CP Variables}
    Given $A \in \{ -3 \ldots 9 \}$:
\only<1>{
    \begin{align*}
        a_{{=}-3} + a_{{=}-2} + a_{{=}-1} + a_{{=}0} + a_{{=}1} + a_{{=}2}
        + a_{{=}3} \\ +~a_{{=}4} + a_{{=}5} + a_{{=}6} + a_{{=}7}
        + a_{{=}8} + a_{{=}9} &= 1
    \end{align*}
}\only<2->{
\begin{align*}
    -16 a_{{\operatorname{neg}}} + 1 a_{{\operatorname{b}}0} + 2 a_{{\operatorname{b}}1} + 4
    a_{{\operatorname{b}}2} + 8 a_{{\operatorname{b}}3} &\ge -3
    \textnormal{~and}\\
    16 a_{{\operatorname{neg}}} + -1 a_{{\operatorname{b}}0} + -2 a_{{\operatorname{b}}1} +
    -4 a_{{\operatorname{b}}2} + -8 a_{{\operatorname{b}}3} &\ge -9
\end{align*}

    \only<3->{
    Then where needed, define:
    \begin{align*}
        a_{{\ge}4} & \leftrightarrow -16 a_{{\operatorname{neg}}} + 1 a_{{\operatorname{b}}0} + 2 a_{{\operatorname{b}}1} + 4
        a_{{\operatorname{b}}2} + 8 a_{{\operatorname{b}}3} &\ge 4 \\
        a_{{\ge}5} & \leftrightarrow -16 a_{{\operatorname{neg}}} + 1 a_{{\operatorname{b}}0} + 2 a_{{\operatorname{b}}1} + 4
        a_{{\operatorname{b}}2} + 8 a_{{\operatorname{b}}3} &\ge 5 \\
        a_{{=}4} & \leftrightarrow a_{{\ge}4} \land \overline{a}_{{\ge}5}
    \end{align*}

    We can do this in the pseudo-Boolean model, where needed, or lazily inside
    the proof using extension variables.
}}
\end{frame}

\begin{frame}{Compiling Constraints}
    \only<1>{
        \begin{itemize}
            \item Also need to compile every constraint to pseudo-Boolean form.
            \item Doesn't need to be a propagating encoding.
            \item Can use additional variables.
        \end{itemize}
    }\only<2>{
    Given $2A + 3B + 4C \ge 42$, where $A, B, C \in \{ -3 \ldots 9 \}$,
\begin{align*}
    -32 a_{{\operatorname{neg}}} + 2 a_{{\operatorname{b}}0} + 4 a_{{\operatorname{b}}1} + 8
    a_{{\operatorname{b}}2} + 16 a_{{\operatorname{b}}3} \\
    + -48 b_{{\operatorname{neg}}} + 3 b_{{\operatorname{b}}0} + 6
    b_{{\operatorname{b}}1} + 12 b_{{\operatorname{b}}2} + 24 b_{{\operatorname{b}}3}\\
    + -64 c_{{\operatorname{neg}}} + 4 c_{{\operatorname{b}}0} + 8
    c_{{\operatorname{b}}1} + 16 c_{{\operatorname{b}}2} + 32 c_{{\operatorname{b}}3} & \ge 42 \textnormal{.}
\end{align*}}\only<3>{
    Given $(A, B, C) \in [(1, 2, 3), (1, 3, 4), (2, 2, 5)]$, define
    \begin{align*}
        3\overline{t}_{0} + a_{{=}1} + b_{{=}2} + c_{{=}3} \ge 3 &\quad \text{i.e.}&t_{0} \rightarrow (a_{{=}1} \wedge b_{{=}2} \wedge c_{{=}3}) \\
        3\overline{t}_{1} + a_{{=}1} + b_{{=}4} + c_{{=}4} \ge 3 &\quad \text{i.e.}&t_{1} \rightarrow (a_{{=}1} \wedge b_{{=}4} \wedge c_{{=}4}) \\
        3\overline{t}_{2} + a_{{=}2} + b_{{=}2} + c_{{=}5} \ge 3 &\quad \text{i.e.}&t_{2} \rightarrow (a_{{=}2} \wedge b_{{=}2} \wedge c_{{=}5})
    \end{align*} using a tuple selector variable \begin{align*}
        &t_{0} + t_{1} + t_{2} = 1
    \end{align*}}
\end{frame}

\begin{frame}{Proof Logging Search Trees}
    Want to just output a reverse unit propagation step on every backtrack.

    \bigskip

    This works for forward-checking / DPLL, but not with strong propagators.

    \bigskip

    The key invariant: any propagation visible to the CP solver must be reflected either
    \begin{itemize}
        \item By ``unit propagation'' on the pseudo-Boolean model,
        \item Or by reverse unit propagation on the backtrack clause.
    \end{itemize}
\end{frame}

\begin{frame}{Proof Logging Inference: The Easy Cases}
    If it follows from bounds consistency on the pseudo-Boolean model,
    no further proof logging needed.

    \bigskip

    For example, a tuple in a table constraint becoming infeasible.

    \bigskip

    Intuition: some facts are so obvious they don't need stated.
\end{frame}

\begin{frame}{Proof Logging Inference: Using RUP}
    Some facts are ``obvious'' once we tell the proof verifier they are true,
    but not otherwise.

    \bigskip

    For example, a variable losing a value due to a table constraint.

    \bigskip

    We log these propagations using RUP.

    \bigskip

    Intuition: like singleton arc consistency.
\end{frame}

\begin{frame}{Proof Logging Inference: Explicit Justifications}
    Some facts aren't ``obvious'' but can be justified explicitly.

    \bigskip

    All-different: sum up the ``variable takes at least one value'' and ``value is used at most once'' constraints for a Hall set or Hall violator.

    \bigskip

    Integer linear inequalities: the slack algorithm gives an easy proof.
\end{frame}

\begin{frame}[t]{Justifying All-Different Failures}%
\begin{tabular}
    {r@{\hspace*{0mm}}c@{\hspace*{0.5mm}}c@{\hspace*{0.5mm}}c@{\hspace{0.5mm}}c@{\hspace*{0.5mm}}
    r@{\hspace*{3mm}}
    r@{\hspace*{0.7mm}}r@{\hspace*{0.7mm}}r@{\hspace*{0.7mm}}r@{\hspace*{0.7mm}}r@{\hspace*{0.7mm}}r@{\hspace*{0.7mm}}r@{\hspace*{0.7mm}}r@{\hspace*{0.7mm}}r@{\hspace*{0.7mm}}
    ll}
    $V \in \{$
    &
      $1$
    &
    &
    &
      $4$ \hspace*{1.2mm} $5$
    &
      $\}$
    & \phantom{$-v_{{=}1}$}
    &
    & \phantom{$-w_{{=}1}$}
    &
    & \phantom{$-x_{{=}1}$}
    &
    & \phantom{$-y_{{=}1}$}
    &
    & \phantom{$-z_{{=}1}$}
    &
    \\

    $\alertblue<2->{W}
    \in \{$
    &
      \alertred<3>{$1$}
    &
      \alertred<3>{$2$}
    &
      \alertred<3>{$3$}
    &
    &
      $\}$
    &
      $
      \only<1-2>{\phantom{w_{{=}1}}}\only<3->{\alertred<3>{w_{{=}1}}}
      $
    &
      $\only<1-2>{\phantom{+}}\only<3->{\alertred<3>{+}}$
    &
      $\only<1-2>{\phantom{w_{{=}2}}}\only<3->{\alertred<3>{w_{{=}2}}}$
    &
      $\only<1-2>{\phantom{+}}\only<3->{\alertred<3>{+}}$
    &
      $\only<1-2>{\phantom{w_{{=}3}}}\only<3->{\alertred<3>{w_{{=}3}}}$
    &
    &
    &
    &
    &
      $\only<1-2>{\phantom{ \ge 1}}\only<3->{\alertred<3>{ \ge 1}}$
    &
      \uncover<3->{
      $W\!$ takes some value}
    \\
    $\alertblue<2->{X} \in \{$
    &
    &
      $2$
    &
      $3$
    &
    &
      $\}$ &
    &
    &
      $\only<1-3>{\phantom{x_{{=}2}}}\only<4->{x_{{=}2}}$
    &
      $\only<1-3>{\phantom{+}}\only<4->{+}$
    &
      $\only<1-3>{\phantom{x_{{=}3}}}\only<4->{x_{{=}3}}$
    &
    &
    &
    &
    &
      $\only<1-3>{\phantom{ \ge 1}}\only<4->{ \ge 1}$
    &
      \uncover<4->{
      $X$ takes some value}
    \\
    $\alertblue<2->{Y} \in \{$
    &
      $1$
    &
    &
      $3$
    &
    &
      $\}$
    &
      $\only<1-3>{\phantom{y_{{=}1}}}\only<4->{y_{{=}1}}$
    &
    &
    &
      $\only<1-3>{\phantom{+}}\only<4->{+}$
    &
      $\only<1-3>{\phantom{y_{{=}3}}}\only<4->{y_{{=}3}}$
    &
    &
    &
    &
    &
      $\only<1-3>{\phantom{ \ge 1}}\only<4->{ \ge 1}$
    &
      \uncover<4->{
      $Y$ takes some value
      }
    \\
    $\alertblue<2->{Z} \in \{$
    &
      $1$
    &
    &
      $3$
    &
    &
      $\}$
    &
      $\only<1-3>{\phantom{z_{{=}1}}}\only<4->{z_{{=}1}}$
    &
    &
    &
      $\only<1-3>{\phantom{+}}\only<4->{+}$
    &
      $\only<1-3>{\phantom{z_{{=}3}}}\only<4->{z_{{=}3}}$
    &
    &
    &
    &
    &
      $\only<1-3>{\phantom{ \ge 1}}\only<4->{ \ge 1}$
    &
      \uncover<4->{
      $Z$ takes some value
      }
    \\[0.5cm]

    \only<5->{
    &
      $\rightarrow$
    &
    &
    &
    &
    &
      $-v_{{=}1}$
    &
      $+$
    &
      $-w_{{=}1}$
    &
      $+$
    &
    &
    &
      $-y_{{=}1}$
    &
      $+$
    &
      $-z_{{=}1}$
    &
      $ \ge -1$
    &
      \uncover<5->{
      At most  one variable
      $=1$
      }
    \\

    &
    &
      $\rightarrow$
    &
    &
    &
    &
    &
    &
      $-w_{{=}2}$
    &
      $+$
    &
      $-x_{{=}2}$
    &
    &
    &
    &
    &
      $ \ge -1$
    &
      \uncover<5->{
      At most  one variable
      $=2$
      }
    \\

    &
    &
    &
      $\rightarrow$
    &
    &
    &
    &
    &
      $-w_{{=}3}$
    &
      $+$
    &
      $-x_{{=}3}$
    &
      $+$
    &
      $-y_{{=}3}$
    &
      $+$
    &
      $-z_{{=}3}$
    &
    $ \ge -1$
    &
      \uncover<5->{
      At most  one variable
      $=3$
      }
    \\[0.5cm]
}
\only<6->{
    &
    &
    &
    &
    &
    &
      $-v_{{=}1}$
    &
    &
    &
    &
    &
    &
    &
    &
    &
      $ \ge 1$
    &
      \uncover<5->{
      Sum all constraints so far
      }
    \\
    }
\only<7->{
    &
    &
    &
    &
    &
    &
      $ v_{{=}1}$
    &
    &
    &
    &
    &
    &
    &
    &
    &
      $ \ge 0$
    &
      \uncover<5->{
      Variable $ v_{{=}1}$ non-negative
      }
    \\[0.5cm]
}
\only<8->{
    &
    &
    &
    &
    &
    &
      $0$
    &
    &
    &
    &
    &
    &
    &
    &
    &
      $ \ge 1$
    &
      \uncover<5->{
      Sum above two constraints
      }
    \\
}
    &
    $\phantom{\rightarrow}$ &
    $\phantom{\rightarrow}$ &
    $\phantom{\rightarrow}$ &
    &
    &
    $\phantom{-v_{{=}1}}$ &
    $\phantom{+}$ &
    $\phantom{-w_{{=}1}}$ &
    $\phantom{+}$ &
    $\phantom{-y_{{=}1}}$ &
    $\phantom{+}$ &
    $\phantom{-y_{{=}1}}$ &
    $\phantom{+}$ &
    $\phantom{-z_{{=}1}}$ &
    $\phantom{ \ge -1}$ \\
    \end{tabular}
\end{frame}

\begin{frame}{The Glasgow Constraint Solver}
    \begin{center}
        \raisebox{-0.3em}{\url{https://github.com/ciaranm/glasgow-constraint-solver}}
        \bigskip
    \end{center}
    \begin{itemize}
        \item MIT licence, written in fancy modern C++.
        \item All-different, integer linear inequality (including for variables
            with very large domains), smart table, minimum / maximum of an array,
            element, absolute value, knapsack, regular expression,
            Hamiltonian circuit.
    \end{itemize}
\end{frame}

\begin{frame}{How Expensive is Proof Logging?}
    \only<1>{
        \begin{itemize}
            \item Laurent D. Michel, Pierre Schaus, Pascal Van Hentenryck:
                MiniCP: a lightweight solver for constraint programming. Math. Program. Comput.
                13(1) (2021).
            \item Five benchmark problems allowing comparison of solvers ``doing the same thing'':
                \begin{itemize}
                    \item Simple models.
                    \item Fixed search order and well-defined propagation consistency levels.
                    \item Few global constraints (although we don't have circuit yet).
                \end{itemize}
            \item Probably close to the worst case for proof logging performance.
            \item Also: Crystal Maze and World's Hardest Sudoku.
        \end{itemize}
    }\only<2>{
        \begin{itemize}
            \item Our solver: faster than the fastest of MiniCP, OscaR, and Choco.
            \item Proof logging slowdown: between 8.4 to 61.1.
                \begin{itemize}
                    \item 800,000 to 3,000,000 inferences per second.
                    \item Proof logs can be hundreds of GBytes.
                    \item No effort put into making the proof-writing code run fast.
                \end{itemize}
            \item Verification slowdown: a further 10 to 100.
                \begin{itemize}
                    \item Probably possible to reduce this substantially if we are prepared to put more care into writing proofs.
                \end{itemize}
        \end{itemize}}
\end{frame}

\begin{frame}{What Do We Have?}
    \begin{itemize}
        \item Don't know that the solver is correct.
        \item Do know that if a solver ever produces a wrong answer, it can be detected.
            \begin{itemize}
                \item Even if due to a hardware or compiler error, or faulty maths.
                \item We will need to get used to verification being (a constant factor) slower than solving.\pause
                \item Still need the assumption that the pseudo-Boolean problem is correct.
            \end{itemize} \pause
        \item Also helps with testing and solver development: bugs are caught if incorrect reasoning is performed,
            rather than if a wrong answer is produced.\pause
        \item We get an auditable record of exactly what was actually solved.
            \begin{itemize}
                \item Maybe one day this will be standard, if a computer makes a decision affecting
                    you?\pause
            \end{itemize}
        \item Can analse proof logs to design better solvers in the future.
    \end{itemize}
\end{frame}

\begin{frame}{This is Costing the British Public a Million Pounds?}
    \pause
    \begin{itemize}
        \item Royal Academy of Engineering Research Fellowship: 80\% of \textsterling{}625,000 over five years
            for ``Trustworthy Constraint Programming and Optimisation''.\pause
            \vspace*{-0.3cm}\begin{multicols}{2}%
            \begin{itemize}
                \item Salary and NI: \textsterling{}311,875
                \item Travel: \textsterling{}20,000
                \item Equipment: \textsterling{}3,000
                \item Technicians: \textsterling{}2,272\pause
                \item Estates: \textsterling{}47,770
                \item Indirect costs: \textsterling{}230,995\pause
            \end{itemize}%
            \end{multicols}
        \item University money: \textsterling{}100,000 over five years.
            \begin{itemize}
                \item PhD student: \textsterling{}65,311 stipend, \textsterling{}16,651 fees over three
                    and a half years.
                \item Rest on equipment and travel.
            \end{itemize}\pause\medskip
        \item Engineering and Physical Research Council New Investigator Grant: 80\% of \textsterling{}429,243 over next
            three years for ``The Science of Solving Hard Subgraph
            Problems''.%
            \vspace*{-0.3cm}\begin{multicols}{2}%
            \begin{itemize}
                \item Postdoc salary and NI: \textsterling{}158,405
                \item Summer interns salary and NI: \textsterling{}13,008
                \item Travel: \textsterling{}37,500
                \item Technicians: \textsterling{}9,583\pause
                \item Estates: \textsterling{}34,860
                \item Indirect costs: \textsterling{}175,137
            \end{itemize}
            \end{multicols}
    \end{itemize}
\end{frame}

{
    \usebackgroundtemplate{
        \tikz[overlay, remember picture]
        \node[at=(current page.south), anchor=south, inner
        sep=0pt, yshift=-1cm]{\includegraphics[keepaspectratio=true, width=\paperwidth]{background4.jpg}};
    }

    \begin{frame}[plain,noframenumbering]
        \begin{tikzpicture}[remember picture, overlay]
            \node at (current page.north west) {
                \begin{tikzpicture}[remember picture, overlay]
                    \fill [fill=uofguniversityblue, anchor=north west] (0, 0) rectangle (\paperwidth, -2.8cm);
                \end{tikzpicture}
            };

            \node (logo) [anchor=north east, shift={(-0.6cm,-0.2cm)}] at (current page.north east) {
                \includegraphics[keepaspectratio=true,scale=0.5]{UoG_keyline.pdf}
            };

            \node (logo2) [anchor=north, below=0.2cm of logo.south] {
                \includegraphics[keepaspectratio=true,scale=0.1]{RAEngWhite.pdf}
            };

            \coordinate (logos) at ($(logo.south)!0.5!(logo2.north)$);

            \node [anchor=west, xshift=0.2cm] at (current page.west |- logos) {
                \begin{minipage}{0.60\paperwidth}\raggedright
                    \textcolor{white}{\url{https://ciaranm.github.io/}} \\[0.3cm]
                    \textcolor{white}{\href{mailto:ciaran.mccreesh@glasgow.ac.uk}{\nolinkurl{ciaran.mccreesh@glasgow.ac.uk}}}
                \end{minipage}
            };
        \end{tikzpicture}
    \end{frame}
}

\end{document}
